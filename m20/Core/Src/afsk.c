/*
 *	afsk.c
 *	By SQ2IPS
 *  Base implemenatation of AFSK modulation with HDLC Bell 202 tones, sent into ADF module in direct FSK mode. Generated by high freq PWM with changed duty cycle according to a sine table.
 *  Based on https://files.tapr.org/meetings/DCC_2014/DCC2014-Amateur-Bell-202-Modem-W6KWF-and-Bridget-Benson.pdf
 */

#include "afsk.h"
#include "adf.h"
#include "utils.h"
#include "main.h"
#include "config.h"

#include <stdio.h>

static uint8_t sine_table[SINE_TABLE_SIZE];

static bool AFSK_Active = false;

static volatile float phase = 0.0f;
const static float phase_inc_marc = (SINE_TABLE_SIZE * BELL202_MARK)/(float)AFSK_UPDATE_SAMPLERATE;
const static float phase_inc_space = (SINE_TABLE_SIZE * BELL202_SPACE)/(float)AFSK_UPDATE_SAMPLERATE;
static float phase_inc;

static uint8_t bit_sample_counter = 0;
static bool current_tone = 0;
static uint16_t bit_pos = 0;

const static uint8_t buff[] = {0x7e, 0x41, 0x05, 0x25, 0x65, 0x02, 0x02, 0x07, 0x39, 0x79, 0x61, 0x41, 0x19, 0x19, 0x47, 0x75, 0x49, 0x11, 0x51, 0x46, 0x02, 0xc7, 0xc0, 0x07, 0x81, 0x06, 0x4e, 0x26, 0x66, 0x16, 0x56, 0x2f, 0x7a, 0x2e, 0x2a, 0x51, 0x22, 0x6e, 0x47, 0x2d, 0x5e, 0x79, 0x59, 0x25, 0x61, 0x7a, 0x41, 0x5e, 0x06, 0x0e, 0x0e, 0x46, 0x66, 0x26, 0x09, 0x53, 0x1b, 0x1b, 0x7b, 0x02, 0x75, 0x7b, 0x27, 0x1b, 0x13, 0x42, 0x22, 0x89, 0x3f, 0x3f};
const static uint16_t buff_len = sizeof(buff);

static void init_sine_table(void) {
    for (int i = 0; i < SINE_TABLE_SIZE; i++) {
        float s = (Sinf(2.0f * PI * i / SINE_TABLE_SIZE) + 1.0f) * 0.5f;
        sine_table[i] = (uint8_t)(s * (AFSK_PWM_TIM_ARR)); // +1 ???
    }
}

bool AFSK_is_active(){
    return AFSK_Active;
}

void AFSK_stop_TX() {
  TIM2->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the interrupt counter
  TIM2->DIER &= ~(TIM_DIER_UIE); // Disable the interrupt
  
  TIM21->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the PWM counter
  adf_RF_off();                  // turn TX off
  AFSK_Active = false; // flag to off
}

static bool get_next_bit(){
    if(bit_pos < (N2_SEGMENT_COUNT)*8){ // N2
        return (BELL202_N2_N3_FLAG>>(7-(bit_pos%8))) & 1;
    }else if(bit_pos >= N2_SEGMENT_COUNT*8 && bit_pos < (N2_SEGMENT_COUNT+buff_len)*8){ // DATA
        return (buff[(bit_pos/8)-(N2_SEGMENT_COUNT)]>>(7-(bit_pos%8))) & 1;
    }else if(bit_pos >= (N2_SEGMENT_COUNT+buff_len)*8 && bit_pos < (N2_SEGMENT_COUNT+buff_len+N3_SEGMENT_COUNT)*8){ // N3
        return (BELL202_N2_N3_FLAG>>(7-(bit_pos%8))) & 1;
    }
}

void AFSK_timer_handler(){ // Changing tone (TIM2)
    TIM2->CNT = 0; // Reset timer counter

    //uint16_t index = (uint16_t)Round(phase); // get the sin() index value from phase
    //if (index >= SINE_TABLE_SIZE) index -= SINE_TABLE_SIZE;

    TIM21->CCR1 = sine_table[(uint16_t)Round(phase)]; // Set the duty cycle to index from phase

    phase += phase_inc; // increase phase to get wanted frequency
    if (phase >= SINE_TABLE_SIZE) phase -= SINE_TABLE_SIZE; // normalise phase value to be in bounds of array

    if (++bit_sample_counter >= AFSK_UPDATE_SAMPLERATE/AFSK_BAUDRATE){
        bit_sample_counter = 0;

        /* 
         * One implication of using HDLC is that frames are not encoded using the 1200Hz mark and 2200Hz
         * space symbols of traditional Bell 202, but instead use an inverted non-return to zero (NRZI) encoding.
         * NRZI calls for zeros in the original bit stream to be encoded as a continuous-phase frequency
         * transition between consecutive symbols, while ones are encoded as the lack of a frequency change between two symbols.
         */
        if(get_next_bit() == 0) current_tone = !current_tone;

        if(current_tone==1){
            phase_inc = phase_inc_marc;
        }else{
            phase_inc = phase_inc_space;
        }

        bit_pos++;
        if(bit_pos >= (N2_SEGMENT_COUNT+buff_len+N3_SEGMENT_COUNT)*8) AFSK_stop_TX();
    }
}

void AFSK_start_TX() {
  init_sine_table(); // Calculate sin() values for setting duty cycle
  adf_RF_on(QRG_AFSK, PA_FSK4); // turn on radio TX
  AFSK_Active = true;                                 // change status
  current_tone = 1;
  phase_inc = phase_inc_marc;
  bit_pos = 0;

  // TIM2 - Modulation, changing duty cycles
  TIM2->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the TIM Counter
  TIM2->PSC = AFSK_UPDATE_TIM_PSC;
  TIM2->ARR = (SystemCoreClock/AFSK_UPDATE_SAMPLERATE)-1;
  TIM2->CR1 |= TIM_CR1_CEN;     // enable timer again
  TIM2->DIER |= TIM_DIER_UIE;   // Enable the interrupt

  AFSK_timer_handler();

  // TIM21 - PWM timer, Generating tones
  TIM21->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the TIM Counter
  TIM21->PSC = AFSK_PWM_TIM_PSC;
  TIM21->ARR = AFSK_PWM_TIM_ARR;

  TIM21->CCER |= LL_TIM_CHANNEL_CH1; // Set PWM channel
  TIM21->CR1 |= TIM_CR1_CEN;     // enable timer again

}
