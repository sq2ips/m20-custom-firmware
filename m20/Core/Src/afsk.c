/*
 *	afsk.c
 *	By SQ2IPS
 *  Base implemenatation of AFSK modulation with HDLC Bell 202 tones, sent into ADF module in direct FSK mode. Tone generated by high frequency PWM with changed duty cycle according to a sine table. Phase increase value changed according to tone frequency, making a continous phase tone transition.
 *  Modulation documentation https://files.tapr.org/meetings/DCC_2014/DCC2014-Amateur-Bell-202-Modem-W6KWF-and-Bridget-Benson.pdf, https://notblackmagic.com/bitsnpieces/afsk/
 *  Implementation based on https://github.com/trackuino/trackuino/blob/1.52/trackuino/afsk_avr.cpp, https://github.com/mikaelnousiainen/RS41ng?tab=readme-ov-file#si4032-bell-fsk-modulation-hack-for-aprs
 */

#include "afsk.h"
#include "adf.h"
#include "utils.h"
#include "main.h"
#include "config.h"

#include <stdio.h>

static uint8_t sine_table[SINE_TABLE_SIZE]; // The sine lookup table is the carrier signal, its values are set as the PWM dutycycle, it's indexed by a phase value, continously increased in the modulation interrupt by phase_inc_marc for marc tone or phase_inc_space for space tone therefore creating one of each tones with a phase continous transition when changed

static bool AFSK_Active = false; // Activity flag

static volatile float phase = 0.0f; // Current phase value
const static float phase_inc_marc = (SINE_TABLE_SIZE * BELL202_MARK)/(float)AFSK_UPDATE_SAMPLERATE; // Phase increase for generating marc Bell 202 tone
const static float phase_inc_space = (SINE_TABLE_SIZE * BELL202_SPACE)/(float)AFSK_UPDATE_SAMPLERATE; // Phase increase for generating space Bell 202 tone
static float phase_inc; // current phase increase value

static uint8_t bit_sample_counter = 0;
static bool current_tone = 0;
static uint16_t bit_pos = 0;

const static uint8_t buff[] = {0x7e, 0x41, 0x05, 0x25, 0x65, 0x02, 0x02, 0x07, 0x39, 0x79, 0x61, 0x41, 0x19, 0x19, 0x47, 0x75, 0x49, 0x11, 0x51, 0x46, 0x02, 0xc7, 0xc0, 0x07, 0x81, 0x06, 0x4e, 0x26, 0x66, 0x16, 0x56, 0x2f, 0x7a, 0x2e, 0x2a, 0x51, 0x22, 0x6e, 0x47, 0x2d, 0x5e, 0x79, 0x59, 0x25, 0x61, 0x7a, 0x41, 0x5e, 0x06, 0x0e, 0x0e, 0x46, 0x66, 0x26, 0x09, 0x53, 0x1b, 0x1b, 0x7b, 0x02, 0x75, 0x7b, 0x27, 0x1b, 0x13, 0x42, 0x22, 0x89, 0x3f, 0x3f};
const static uint16_t buff_len = sizeof(buff);

static void init_sine_table(void) { // Generate sine lookup table
    for (int i = 0; i < SINE_TABLE_SIZE; i++) {
        float s = (Sinf(2.0f * PI * i / SINE_TABLE_SIZE) + 1.0f) * 0.5f;
        sine_table[i] = (uint8_t)(s * (AFSK_PWM_TIM_ARR)); // +1 ???
    }
}

bool AFSK_is_active(){ // Return activity flag
    return AFSK_Active;
}

void AFSK_stop_TX() { // Disable TX
  TIM2->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the interrupt counter
  TIM2->DIER &= ~(TIM_DIER_UIE); // Disable the interrupt
  
  TIM21->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the PWM counter
  adf_RF_off(); // turn TX off
  AFSK_Active = false; // turn off activty flag
}

// 0, N2-1 | N2, N2+buff_len-1 | buff_len, buff_len+N3-1
static bool get_next_bit(){
    if(bit_pos < (N2_SEGMENT_COUNT)*8){ // N2 octet sync section
        return (BELL202_N2_N3_FLAG>>(7-(bit_pos%8))) & 1;
    }else if(bit_pos >= N2_SEGMENT_COUNT*8 && bit_pos < (N2_SEGMENT_COUNT+buff_len)*8){ // DATA section
        return (buff[(bit_pos/8)-(N2_SEGMENT_COUNT)]>>(7-(bit_pos%8))) & 1;
    }else if(bit_pos >= (N2_SEGMENT_COUNT+buff_len)*8 && bit_pos < (N2_SEGMENT_COUNT+buff_len+N3_SEGMENT_COUNT)*8){ // N3 octet sync section
        return (BELL202_N2_N3_FLAG>>(7-(bit_pos%8))) & 1;
    }
}

void AFSK_timer_handler(){ // Modulation timer (TIM2) changing phase increase according to current tone
    TIM2->CNT = 0; // Reset timer counter

    //uint16_t index = (uint16_t)Round(phase); // get the sin() index value from phase
    //if (index >= SINE_TABLE_SIZE) index -= SINE_TABLE_SIZE;

    TIM21->CCR1 = sine_table[(uint16_t)Round(phase)]; // Set the duty cycle to index from phase

    phase += phase_inc; // increase phase for generating wanted frequency
    if (phase >= SINE_TABLE_SIZE) phase -= SINE_TABLE_SIZE; // normalise phase value to be in bounds of array

    if (++bit_sample_counter >= AFSK_UPDATE_SAMPLERATE/AFSK_BAUDRATE){ // With the baudrate frequency process next bit of data
        bit_sample_counter = 0;

        /* 
         * "One implication of using HDLC is that frames are not encoded using the 1200Hz mark and 2200Hz
         * space symbols of traditional Bell 202, but instead use an inverted non-return to zero (NRZI) encoding.
         * NRZI calls for zeros in the original bit stream to be encoded as a continuous-phase frequency
         * transition between consecutive symbols, while ones are encoded as the lack of a frequency change between two symbols."
         */
        if(get_next_bit() == 0) current_tone = !current_tone; // When bit is 0, change the current frequency, when 1 dont change it

        if(current_tone==1){
            phase_inc = phase_inc_marc;
        }else{
            phase_inc = phase_inc_space;
        }

        bit_pos++; // increase bit counter
        if(bit_pos >= (N2_SEGMENT_COUNT+buff_len+N3_SEGMENT_COUNT)*8) AFSK_stop_TX(); // check for end of transmission
    }
}

void AFSK_start_TX() {
  init_sine_table(); // Calculate sin() values for setting duty cycle
  adf_RF_on(QRG_AFSK, PA_FSK4); // turn on radio TX
  AFSK_Active = true; // turn on activity flag
  current_tone = 1; // start tone is marc
  phase_inc = phase_inc_marc; // first phase increase for marc tone
  bit_pos = 0; // reset bit position counter

  // TIM2 - Modulation, changing duty cycles
  TIM2->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the TIM Counter
  TIM2->PSC = AFSK_UPDATE_TIM_PSC;
  TIM2->ARR = (SystemCoreClock/AFSK_UPDATE_SAMPLERATE)-1;
  TIM2->CR1 |= TIM_CR1_CEN;     // enable timer again
  TIM2->DIER |= TIM_DIER_UIE;   // Enable the interrupt

  AFSK_timer_handler(); // Tirgger first modulation iteration to set initial values before PWM will be turned on

  // TIM21 - PWM timer, Generating tones
  TIM21->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN)); // Disable the TIM Counter
  TIM21->PSC = AFSK_PWM_TIM_PSC; // Set prescaler
  TIM21->ARR = AFSK_PWM_TIM_ARR; // Set autoreload

  TIM21->CCER |= LL_TIM_CHANNEL_CH1; // Set PWM channel
  TIM21->CR1 |= TIM_CR1_CEN;     // enable timer again

}
